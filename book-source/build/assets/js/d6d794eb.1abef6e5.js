"use strict";(self.webpackChunkphysical_ai_robotics_textbook=self.webpackChunkphysical_ai_robotics_textbook||[]).push([[1516],{8423:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapter-4-ai-integration/lesson-5-manipulation-grasping","title":"Lesson 5: Manipulation, Grasping & Motion Planning","description":"Learning Objectives","source":"@site/docs/03-chapter-4-ai-integration/05-lesson-5-manipulation-grasping.md","sourceDirName":"03-chapter-4-ai-integration","slug":"/chapter-4-ai-integration/lesson-5-manipulation-grasping","permalink":"/physical-ai-robotics-textbook/docs/chapter-4-ai-integration/lesson-5-manipulation-grasping","draft":false,"unlisted":false,"editUrl":"https://github.com/devhammad0/physical-ai-robotics-textbook/tree/main/docs/03-chapter-4-ai-integration/05-lesson-5-manipulation-grasping.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 4: LLM-Driven Planning & Task Decomposition","permalink":"/physical-ai-robotics-textbook/docs/chapter-4-ai-integration/lesson-4-llm-planning"},"next":{"title":"Lesson 6: Full-Stack Integration & Orchestration","permalink":"/physical-ai-robotics-textbook/docs/chapter-4-ai-integration/lesson-6-full-integration"}}');var a=e(6070),s=e(8439);const t={},o="Lesson 5: Manipulation, Grasping & Motion Planning",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"What is Grasp Planning?",id:"what-is-grasp-planning",level:2},{value:"Grasp Anatomy",id:"grasp-anatomy",level:3},{value:"Grasp Quality Metrics",id:"grasp-quality-metrics",level:3},{value:"Motion Planning: Computing Collision-Free Paths",id:"motion-planning-computing-collision-free-paths",level:2},{value:"RRT (Rapidly-Exploring Random Trees) Algorithm",id:"rrt-rapidly-exploring-random-trees-algorithm",level:3},{value:"Manipulation Pipeline",id:"manipulation-pipeline",level:2},{value:"Grasp Planner Implementation",id:"grasp-planner-implementation",level:2},{value:"Motion Planning with RRT",id:"motion-planning-with-rrt",level:2},{value:"Force Control &amp; Gripper",id:"force-control--gripper",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise L5-1: Grasp Planning",id:"exercise-l5-1-grasp-planning",level:3},{value:"Exercise L5-2: RRT Motion Planning",id:"exercise-l5-2-rrt-motion-planning",level:3},{value:"Real Hardware Considerations",id:"real-hardware-considerations",level:2},{value:"Differences from Simulation",id:"differences-from-simulation",level:3},{value:"Handling Grasp Failures",id:"handling-grasp-failures",level:3},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(n){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"lesson-5-manipulation-grasping--motion-planning",children:"Lesson 5: Manipulation, Grasping & Motion Planning"})}),"\n",(0,a.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(r.p,{children:"By the end of this lesson, you will:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Understand grasp planning: how to compute stable grasping strategies for objects"}),"\n",(0,a.jsx)(r.li,{children:"Implement motion planning: compute collision-free arm trajectories"}),"\n",(0,a.jsx)(r.li,{children:"Integrate grasp + motion planning into cohesive manipulation pipeline"}),"\n",(0,a.jsx)(r.li,{children:"Validate grasps for stability and feasibility before execution"}),"\n",(0,a.jsx)(r.li,{children:"Handle gripper control with force feedback"}),"\n",(0,a.jsx)(r.li,{children:"Understand real hardware challenges in manipulation (friction, slippage, deformation)"}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"what-is-grasp-planning",children:"What is Grasp Planning?"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Grasp planning"}),' answers: "How should the robot hold this object?"']}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"Input: Detected object (position, shape, material)\r\n       \u2193\r\n   Grasp Planner\r\n       \u2193\r\nOutput: Multiple grasp candidates ranked by quality\r\n        - Gripper position [x, y, z]\r\n        - Gripper orientation (roll, pitch, yaw)\r\n        - Grasp quality score [0.0, 1.0]\r\n        - Required gripper force [Newtons]\r\n        - Stability prediction\n"})}),"\n",(0,a.jsx)(r.h3,{id:"grasp-anatomy",children:"Grasp Anatomy"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"       Gripper\r\n         \u2193\u2191\r\n       [==]\r\n       \u2502\u2502\u2502\u2502\r\n       \u2502\u2502\u2502\u2502  \u2190 Fingers/jaws\r\n       \u2502\u2502\u2502\u2502\r\n    \u250c\u2500\u2500\u2534\u2534\u2500\u2500\u2510\r\n    \u2502      \u2502  \u2190 Object\r\n    \u2502  \u25ef   \u2502     (center of mass here)\r\n    \u2502      \u2502\r\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nGood grasp:\r\n- Center gripper over object center of mass\r\n- Apply force perpendicular to grasp surface\r\n- Avoid unstable contact points\r\n- Minimize torque that could cause rolling\r\n\r\nBad grasp (will fail):\r\n- Contact point far from COM \u2192 rotation\r\n- Insufficient contact area \u2192 slippage\r\n- Gripper too narrow/wide \u2192 can't grip\n"})}),"\n",(0,a.jsx)(r.h3,{id:"grasp-quality-metrics",children:"Grasp Quality Metrics"}),"\n",(0,a.jsxs)(r.table,{children:[(0,a.jsx)(r.thead,{children:(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.th,{children:"Metric"}),(0,a.jsx)(r.th,{children:"Formula"}),(0,a.jsx)(r.th,{children:"Interpretation"})]})}),(0,a.jsxs)(r.tbody,{children:[(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:"Grasp Closure"})}),(0,a.jsx)(r.td,{children:"Force-closure test"}),(0,a.jsx)(r.td,{children:"Can gripper prevent any motion?"})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:"Margin to Failure"})}),(0,a.jsx)(r.td,{children:"Minimum friction needed"}),(0,a.jsx)(r.td,{children:"How robust is grasp?"})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:"Contact Stability"})}),(0,a.jsx)(r.td,{children:"Distance from contact edge"}),(0,a.jsx)(r.td,{children:"Stability against perturbations"})]}),(0,a.jsxs)(r.tr,{children:[(0,a.jsx)(r.td,{children:(0,a.jsx)(r.strong,{children:"Dexterity"})}),(0,a.jsx)(r.td,{children:"Condition number of grasp matrix"}),(0,a.jsx)(r.td,{children:"Can gripper achieve all wrist motions?"})]})]})]}),"\n",(0,a.jsx)(r.h2,{id:"motion-planning-computing-collision-free-paths",children:"Motion Planning: Computing Collision-Free Paths"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Motion planning"}),' answers: "What path should the arm take?"']}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"       Goal\r\n       \u2197\r\n      /\r\n     / (obstacle-free path)\r\n    /\r\n   /\r\nStart ---- (blocked)\r\n  \u2193 Can't go straight (obstacle in way)\r\nObstacle\n"})}),"\n",(0,a.jsx)(r.h3,{id:"rrt-rapidly-exploring-random-trees-algorithm",children:"RRT (Rapidly-Exploring Random Trees) Algorithm"}),"\n",(0,a.jsxs)(r.p,{children:["One popular algorithm: ",(0,a.jsx)(r.strong,{children:"RRT"})," \u2014 rapidly explores workspace"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"1. Start: home position (joint angles)\r\n2. Goal: target position\r\n3. Repeat:\r\n   - Sample random configuration\r\n   - Find nearest node in tree\r\n   - Extend tree toward sample\r\n   - Check collision-free\r\n   - If collision-free, add node\r\n   - If reached goal, return path\r\n4. Smooth path (remove unnecessary waypoints)\n"})}),"\n",(0,a.jsx)(r.p,{children:(0,a.jsx)(r.strong,{children:"Why RRT?"})}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"\u2713 Works in high-dimensional spaces (7-DOF arm)"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Probabilistically complete (will find path if one exists)"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Fast (often <1 second)"}),"\n",(0,a.jsx)(r.li,{children:"\u2717 Doesn't guarantee optimal path"}),"\n",(0,a.jsx)(r.li,{children:"\u2717 May find awkward trajectories"}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"manipulation-pipeline",children:"Manipulation Pipeline"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Detected Object\u2502\r\n\u2502 (position, size)\u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n         \u2502\r\n         \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Grasp Planner       \u2502\r\n\u2502  \u2022 Sample grasps     \u2502\r\n\u2502  \u2022 Score each grasp  \u2502\r\n\u2502  \u2022 Rank by quality   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n         \u2502\r\n         \u2193 GraspCandidate[]\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Grasp Validator         \u2502\r\n\u2502  \u2022 Check gripper limits  \u2502\r\n\u2502  \u2022 Check workspace bounds\u2502\r\n\u2502  \u2022 Validate stability    \u2502\r\n\u2502  \u2022 Rank feasible grasps  \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n         \u2502\r\n         \u2193 Best grasp\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Motion Planner          \u2502\r\n\u2502  \u2022 Plan approach path    \u2502\r\n\u2502  \u2022 Plan lift trajectory  \u2502\r\n\u2502  \u2022 Collision checking    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n         \u2502\r\n         \u2193 Trajectory\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Trajectory Executor     \u2502\r\n\u2502  \u2022 Send to robot control \u2502\r\n\u2502  \u2022 Monitor gripper force \u2502\r\n\u2502  \u2022 Handle failures       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(r.h2,{id:"grasp-planner-implementation",children:"Grasp Planner Implementation"}),"\n",(0,a.jsxs)(r.p,{children:["File: ",(0,a.jsx)(r.code,{children:"chapter4_manipulation/src/grasp_planner_node.py"})]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nimport json\r\nimport numpy as np\r\nfrom datetime import datetime\r\nimport uuid\r\n\r\nclass GraspPlannerNode(Node):\r\n    def __init__(self):\r\n        super().__init__('grasp_planner_node')\r\n\r\n        # Subscribe to detections\r\n        self.detections_sub = self.create_subscription(\r\n            String,\r\n            '/robot/detections',\r\n            self.detections_callback,\r\n            10\r\n        )\r\n\r\n        # Publish grasp candidates\r\n        self.grasps_pub = self.create_publisher(\r\n            String,\r\n            '/robot/grasp_candidates',\r\n            10\r\n        )\r\n\r\n        # Gripper configuration\r\n        self.gripper_width = 0.08  # Max opening width (m)\r\n        self.gripper_max_force = 100.0  # Max force (N)\r\n        self.gripper_fingers = 2  # Number of fingers\r\n\r\n        # Workspace bounds\r\n        self.workspace_min = np.array([-0.5, -0.5, 0.3])\r\n        self.workspace_max = np.array([1.0, 0.5, 2.0])\r\n\r\n        self.get_logger().info('Grasp Planner Node initialized')\r\n\r\n    def detections_callback(self, msg):\r\n        \"\"\"Process detected object and generate grasps\"\"\"\r\n        try:\r\n            detections = json.loads(msg.data)\r\n            for detection in detections.get('detections', []):\r\n                grasps = self.plan_grasps(detection)\r\n                if grasps:\r\n                    self._publish_grasps(grasps)\r\n        except json.JSONDecodeError:\r\n            self.get_logger().warn('Failed to parse detections')\r\n\r\n    def plan_grasps(self, detection: dict, num_candidates: int = 5) -> list:\r\n        \"\"\"Generate grasp candidates for detected object\"\"\"\r\n        grasps = []\r\n\r\n        try:\r\n            # Extract object properties\r\n            bbox = detection.get('bbox', {})\r\n            class_name = detection.get('class', 'unknown')\r\n            confidence = detection.get('confidence', 0.5)\r\n\r\n            # Object center (in pixel space)\r\n            pixel_x = (bbox.get('x1', 0) + bbox.get('x2', 0)) / 2.0\r\n            pixel_y = (bbox.get('y1', 0) + bbox.get('y2', 0)) / 2.0\r\n            pixel_z = 0.5  # Assume center depth (would come from depth camera)\r\n\r\n            # Estimate 3D position (simplified - would use depth)\r\n            obj_pos_3d = np.array([pixel_x / 640 * 1.5, pixel_y / 480 * 1.0, pixel_z])\r\n\r\n            # Generate grasps from multiple angles\r\n            for approach_angle in np.linspace(0, 2*np.pi, num_candidates):\r\n                grasp = self._generate_grasp_candidate(\r\n                    obj_pos_3d, approach_angle, class_name, confidence\r\n                )\r\n\r\n                # Validate grasp\r\n                if self._validate_grasp(grasp):\r\n                    quality = self._calculate_grasp_quality(grasp)\r\n                    grasp['grasp_quality'] = quality\r\n                    grasps.append(grasp)\r\n\r\n            # Sort by quality (descending)\r\n            grasps.sort(key=lambda g: g['grasp_quality'], reverse=True)\r\n\r\n            self.get_logger().info(f'Generated {len(grasps)} valid grasps for {class_name}')\r\n            return grasps\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Grasp planning failed: {e}')\r\n            return []\r\n\r\n    def _generate_grasp_candidate(self, object_pos: np.ndarray, angle: float,\r\n                                 class_name: str, confidence: float) -> dict:\r\n        \"\"\"Generate single grasp candidate\"\"\"\r\n        # Approach direction (circular around object)\r\n        approach_offset = 0.1  # 10cm away from object\r\n        approach_x = object_pos[0] + approach_offset * np.cos(angle)\r\n        approach_y = object_pos[1] + approach_offset * np.sin(angle)\r\n        approach_z = object_pos[2] + 0.05  # Slightly above\r\n\r\n        # Grasp orientation (fingers point down)\r\n        gripper_roll = angle\r\n        gripper_pitch = np.pi / 4  # 45 degrees down\r\n        gripper_yaw = 0.0\r\n\r\n        return {\r\n            'grasp_id': str(uuid.uuid4()),\r\n            'object_class': class_name,\r\n            'object_confidence': float(confidence),\r\n            'gripper_position': [approach_x, approach_y, approach_z],\r\n            'gripper_orientation': [gripper_roll, gripper_pitch, gripper_yaw],\r\n            'approach_angle': float(angle),\r\n            'required_force': 50.0  # Default gripper force in Newtons\r\n        }\r\n\r\n    def _validate_grasp(self, grasp: dict) -> bool:\r\n        \"\"\"Check if grasp is physically feasible\"\"\"\r\n        pos = np.array(grasp['gripper_position'])\r\n\r\n        # Check workspace bounds\r\n        if not np.all(pos >= self.workspace_min) or not np.all(pos <= self.workspace_max):\r\n            return False\r\n\r\n        # Check force is reasonable\r\n        if grasp['required_force'] > self.gripper_max_force:\r\n            return False\r\n\r\n        # Check gripper width\r\n        if self.gripper_width < 0.02 or self.gripper_width > 0.2:\r\n            return False\r\n\r\n        return True\r\n\r\n    def _calculate_grasp_quality(self, grasp: dict) -> float:\r\n        \"\"\"Calculate grasp quality score [0.0, 1.0]\"\"\"\r\n        # Combine multiple factors\r\n        quality = 0.5  # Base score\r\n\r\n        # Factor 1: Object detection confidence\r\n        obj_conf = grasp.get('object_confidence', 0.5)\r\n        quality += 0.2 * obj_conf\r\n\r\n        # Factor 2: Distance to workspace center (grasps in center are more stable)\r\n        workspace_center = (self.workspace_min + self.workspace_max) / 2\r\n        pos = np.array(grasp['gripper_position'])\r\n        distance_to_center = np.linalg.norm(pos - workspace_center)\r\n        max_distance = np.linalg.norm(self.workspace_max - self.workspace_min) / 2\r\n        centering_score = 1.0 - (distance_to_center / max_distance)\r\n        quality += 0.3 * max(0, centering_score)\r\n\r\n        # Clamp to [0.0, 1.0]\r\n        return min(1.0, max(0.0, quality))\r\n\r\n    def _publish_grasps(self, grasps: list) -> None:\r\n        \"\"\"Publish grasp candidates\"\"\"\r\n        msg = String()\r\n        msg.data = json.dumps({\r\n            'timestamp': datetime.now().isoformat(),\r\n            'grasps': grasps,\r\n            'num_candidates': len(grasps)\r\n        })\r\n        self.grasps_pub.publish(msg)\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    grasp_planner = GraspPlannerNode()\r\n    rclpy.spin(grasp_planner)\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(r.h2,{id:"motion-planning-with-rrt",children:"Motion Planning with RRT"}),"\n",(0,a.jsxs)(r.p,{children:["File: ",(0,a.jsx)(r.code,{children:"chapter4_manipulation/src/motion_planner_node.py"})]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nimport json\r\nimport numpy as np\r\nfrom datetime import datetime\r\nimport uuid\r\nimport time\r\n\r\nclass MotionPlannerNode(Node):\r\n    def __init__(self):\r\n        super().__init__('motion_planner_node')\r\n\r\n        # Subscribe to grasps\r\n        self.grasps_sub = self.create_subscription(\r\n            String,\r\n            '/robot/grasp_candidates',\r\n            self.grasps_callback,\r\n            10\r\n        )\r\n\r\n        # Publish trajectories\r\n        self.trajectory_pub = self.create_publisher(\r\n            String,\r\n            '/robot/planned_trajectory',\r\n            10\r\n        )\r\n\r\n        # Robot configuration\r\n        self.num_joints = 7\r\n        self.home_config = [0.0] * 7  # Neutral joint angles\r\n\r\n        # Motion planning parameters\r\n        self.rrt_iterations = 1000\r\n        self.step_size = 0.1\r\n        self.planning_timeout = 5.0\r\n\r\n        self.get_logger().info('Motion Planner Node initialized')\r\n\r\n    def grasps_callback(self, msg):\r\n        \"\"\"Process grasp candidates and plan motion\"\"\"\r\n        try:\r\n            grasps_data = json.loads(msg.data)\r\n            for grasp in grasps_data.get('grasps', []):\r\n                trajectory = self.plan_trajectory(grasp)\r\n                if trajectory:\r\n                    self._publish_trajectory(trajectory)\r\n                    return  # Use first valid trajectory\r\n        except json.JSONDecodeError:\r\n            self.get_logger().warn('Failed to parse grasps')\r\n\r\n    def plan_trajectory(self, grasp: dict) -> dict:\r\n        \"\"\"Plan collision-free trajectory to grasp\"\"\"\r\n        try:\r\n            # Simplified RRT implementation\r\n            start = self.home_config\r\n            goal_pos = grasp['gripper_position']\r\n\r\n            # Plan approach phase\r\n            approach_path = self._plan_rrt(start, goal_pos)\r\n            if not approach_path:\r\n                self.get_logger().warn('Failed to plan approach trajectory')\r\n                return None\r\n\r\n            # Create complete trajectory (approach + grasp + retract)\r\n            trajectory = {\r\n                'trajectory_id': str(uuid.uuid4()),\r\n                'phases': [\r\n                    {'name': 'approach', 'waypoints': approach_path},\r\n                    {'name': 'grasp', 'waypoints': [approach_path[-1]]},  # Close gripper\r\n                    {'name': 'retract', 'waypoints': [self.home_config]}   # Return home\r\n                ],\r\n                'estimated_duration': len(approach_path) * 0.5,  # ~0.5s per waypoint\r\n                'collision_free': True\r\n            }\r\n\r\n            return trajectory\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f'Motion planning failed: {e}')\r\n            return None\r\n\r\n    def _plan_rrt(self, start: list, goal: list, max_iterations: int = 1000) -> list:\r\n        \"\"\"Plan path using RRT algorithm\"\"\"\r\n        tree = [start]\r\n        goal_reached = False\r\n\r\n        for iteration in range(max_iterations):\r\n            # Sample random configuration\r\n            if np.random.rand() < 0.1:  # 10% goal bias\r\n                random_config = goal\r\n            else:\r\n                random_config = [np.random.uniform(-np.pi, np.pi) for _ in range(self.num_joints)]\r\n\r\n            # Find nearest node in tree\r\n            nearest = self._nearest_node(tree, random_config)\r\n\r\n            # Extend toward random sample\r\n            new_node = self._extend(nearest, random_config)\r\n\r\n            # Check collision-free\r\n            if self._is_collision_free(nearest, new_node):\r\n                tree.append(new_node)\r\n\r\n                # Check if goal reached\r\n                if self._distance(new_node, goal) < 0.1:\r\n                    goal_reached = True\r\n                    break\r\n\r\n        if goal_reached:\r\n            # Reconstruct path (simplified)\r\n            return tree[-20:]  # Return last 20 nodes as path\r\n        else:\r\n            self.get_logger().warn(f'RRT failed to find path after {max_iterations} iterations')\r\n            return None\r\n\r\n    def _nearest_node(self, tree: list, target: list) -> list:\r\n        \"\"\"Find nearest node in tree to target\"\"\"\r\n        return min(tree, key=lambda node: self._distance(node, target))\r\n\r\n    def _extend(self, start: list, target: list) -> list:\r\n        \"\"\"Extend from start toward target\"\"\"\r\n        direction = np.array(target) - np.array(start)\r\n        norm = np.linalg.norm(direction)\r\n        if norm > 1e-6:\r\n            direction = direction / norm\r\n        return (np.array(start) + self.step_size * direction).tolist()\r\n\r\n    def _distance(self, config1: list, config2: list) -> float:\r\n        \"\"\"Euclidean distance between configurations\"\"\"\r\n        return np.linalg.norm(np.array(config1) - np.array(config2))\r\n\r\n    def _is_collision_free(self, config1: list, config2: list) -> bool:\r\n        \"\"\"Check if motion is collision-free (simplified)\"\"\"\r\n        # In real implementation, would check against scene geometry\r\n        # For now, always return True (simulation assumes no obstacles)\r\n        return True\r\n\r\n    def _publish_trajectory(self, trajectory: dict) -> None:\r\n        \"\"\"Publish planned trajectory\"\"\"\r\n        msg = String()\r\n        msg.data = json.dumps(trajectory)\r\n        self.trajectory_pub.publish(msg)\r\n        self.get_logger().info(f'Published trajectory with {len(trajectory[\"phases\"])} phases')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    motion_planner = MotionPlannerNode()\r\n    rclpy.spin(motion_planner)\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(r.h2,{id:"force-control--gripper",children:"Force Control & Gripper"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:'class GripperController:\r\n    """Control gripper with force feedback"""\r\n\r\n    def __init__(self, max_force=100.0, finger_width=0.08):\r\n        self.max_force = max_force\r\n        self.finger_width = finger_width\r\n        self.current_force = 0.0\r\n        self.current_width = finger_width\r\n\r\n    def open(self):\r\n        """Open gripper fully"""\r\n        self.current_width = self.finger_width\r\n        self.current_force = 0.0\r\n\r\n    def close(self, target_force: float):\r\n        """Close gripper to target force"""\r\n        if target_force > self.max_force:\r\n            self.get_logger().warn(f\'Force {target_force}N exceeds limit {self.max_force}N\')\r\n            target_force = self.max_force\r\n\r\n        # Simulate closing until force reached\r\n        self.current_force = target_force\r\n        self.current_width = max(0.0, self.finger_width - 0.04)  # Close to ~4cm\r\n\r\n    def adjust_force(self, delta_force: float):\r\n        """Adjust gripper force by delta"""\r\n        self.current_force = max(0, min(self.max_force, self.current_force + delta_force))\r\n\r\n    def get_state(self) -> dict:\r\n        return {\r\n            \'current_force\': self.current_force,\r\n            \'current_width\': self.current_width,\r\n            \'is_open\': self.current_width > 0.05\r\n        }\n'})}),"\n",(0,a.jsx)(r.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsx)(r.h3,{id:"exercise-l5-1-grasp-planning",children:"Exercise L5-1: Grasp Planning"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Objective"}),": Understand grasp quality metrics and planning"]}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Load an image of an object in the workspace"}),"\n",(0,a.jsxs)(r.li,{children:["Manually identify:","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Good grasp points (center of mass, stable contact)"}),"\n",(0,a.jsx)(r.li,{children:"Bad grasp points (edge, unstable contact)"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.li,{children:"Implement grasp candidate sampling (at least 6 angles)"}),"\n",(0,a.jsx)(r.li,{children:"Score each grasp by stability"}),"\n",(0,a.jsx)(r.li,{children:"Rank and visualize top 3 grasps"}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Success Criteria"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"\u2713 Generate \u22656 grasp candidates"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Quality scores reflect stability"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Identify which grasps are feasible"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Can explain why top grasp is best"}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"exercise-l5-2-rrt-motion-planning",children:"Exercise L5-2: RRT Motion Planning"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Objective"}),": Implement collision-free path planning"]}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Steps"}),":"]}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"Create 2D workspace with obstacles"}),"\n",(0,a.jsx)(r.li,{children:"Implement RRT algorithm (pseudo-code provided)"}),"\n",(0,a.jsx)(r.li,{children:"Plan path from start to goal"}),"\n",(0,a.jsx)(r.li,{children:"Visualize tree and final path"}),"\n",(0,a.jsx)(r.li,{children:"Measure planning time and path quality"}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Success Criteria"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"\u2713 RRT finds collision-free path"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Planning time <1 second"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Path is continuous and smooth"}),"\n",(0,a.jsx)(r.li,{children:"\u2713 Can adjust parameters (iterations, step size)"}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"real-hardware-considerations",children:"Real Hardware Considerations"}),"\n",(0,a.jsx)(r.h3,{id:"differences-from-simulation",children:"Differences from Simulation"}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Simulation"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Perfect physics (same object \u2192 same grasp success rate)"}),"\n",(0,a.jsx)(r.li,{children:"No slip or deformation"}),"\n",(0,a.jsx)(r.li,{children:"Gripper force perfectly calibrated"}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Real Hardware"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Object friction unknown (can slip unexpectedly)"}),"\n",(0,a.jsx)(r.li,{children:"Gripper jaws deform under load"}),"\n",(0,a.jsx)(r.li,{children:"Sensor calibration drift over time"}),"\n",(0,a.jsx)(r.li,{children:"Unexpected object properties (wet surface, soft material)"}),"\n",(0,a.jsx)(r.li,{children:"Collision detection imperfect"}),"\n"]}),"\n",(0,a.jsx)(r.h3,{id:"handling-grasp-failures",children:"Handling Grasp Failures"}),"\n",(0,a.jsx)(r.p,{children:"On real robots, grasps fail regularly. Solutions:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Tactile Feedback"}),": Monitor gripper force to detect slip"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Vision-based Validation"}),": Check if object moved as expected"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Replanning"}),": If grasp fails, try different grasp"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Adaptive Force"}),": Increase gripper force if object slips"]}),"\n"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"def execute_grasp_with_recovery(grasp_candidates):\r\n    for grasp in grasp_candidates:\r\n        try:\r\n            # Plan trajectory\r\n            trajectory = motion_planner.plan(grasp)\r\n\r\n            # Execute approach\r\n            execute_trajectory(trajectory['approach'])\r\n\r\n            # Close gripper\r\n            gripper.close(force=grasp['required_force'])\r\n\r\n            # Check if grasp stable\r\n            if gripper.detect_slip():\r\n                gripper.increase_force(10)  # Add 10N\r\n\r\n            # Lift\r\n            execute_trajectory(trajectory['lift'])\r\n\r\n            # Success!\r\n            return grasp\r\n\r\n        except GraspFailure:\r\n            continue  # Try next grasp\r\n\r\n    raise Exception(\"All grasps failed\")\n"})}),"\n",(0,a.jsx)(r.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Grasp planning"})," generates multiple candidates ranked by stability"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Motion planning"})," (RRT) computes collision-free paths"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Validation"})," is essential before execution"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Real robots"})," need force feedback and failure recovery"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"Replanning"})," on failure is standard practice"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(r.p,{children:["In ",(0,a.jsx)(r.strong,{children:"Lesson 6"}),", you'll integrate grasp planning + motion planning + LLM planning into a ",(0,a.jsx)(r.strong,{children:"unified orchestration system"})," that ties everything together."]}),"\n",(0,a.jsx)(r.p,{children:"See you in Lesson 6! \ud83c\udfaf"})]})}function d(n={}){const{wrapper:r}={...(0,s.R)(),...n.components};return r?(0,a.jsx)(r,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8439:(n,r,e)=>{e.d(r,{R:()=>t,x:()=>o});var i=e(758);const a={},s=i.createContext(a);function t(n){const r=i.useContext(s);return i.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function o(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:t(n.components),i.createElement(s.Provider,{value:r},n.children)}}}]);